`timescale 1ns / 1ps
/*
 * ============================================================
 * Generated by Wokwi2Verilog Compiler
 * Module: example
 * Source: Wokwi C code
 * ============================================================
 */

module example (

    parameter COLOR_BLACK = 0x0000 #define COLOR_BLUE 0x001F #define COLOR_RED 0xF800 #define COLOR_GREEN 0x07E0 #define COLOR_YELLOW 0xFFE0 #define COLOR_WHITE 0xFFFF #define COLOR_CYAN 0x07FF #define COLOR_MAGENTA 0xF81F #define COLOR_GRAY 0x8410 #define COLOR_ORANGE 0xFD20 #define FONT_WIDTH 5 #define FONT_HEIGHT 7 #define FONT_SPACING 1 static const uint8_t font_5x7[][7] = { { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x04 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x05, 0x0F, 0x0F, 0x0A }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x0E, 0x11, 0x13, 0x15, 0x19, 0x11, 0x0E }, { 0x04, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x0E }, { 0x0E, 0x11, 0x01, 0x02, 0x04, 0x08, 0x1F }, { 0x1F, 0x02, 0x04, 0x02, 0x01, 0x11, 0x0E }, { 0x02, 0x06, 0x0A, 0x12, 0x1F, 0x02, 0x02 }, { 0x1F, 0x10, 0x1E, 0x01, 0x01, 0x11, 0x0E }, { 0x06, 0x08, 0x10, 0x1E, 0x11, 0x11, 0x0E }, { 0x1F, 0x01, 0x02, 0x04, 0x08, 0x08, 0x08 }, { 0x0E, 0x11, 0x11, 0x0E, 0x11, 0x11, 0x0E }, { 0x0E, 0x11, 0x11, 0x0F, 0x01, 0x02, 0x0C }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x02, 0x00, 0x04, 0x08, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x0F, 0x01, 0x0F, 0x0B, 0x0F, 0x0F }, { 0x04, 0x0A, 0x11, 0x11, 0x1F, 0x11, 0x11 }, { 0x1E, 0x11, 0x11, 0x1E, 0x11, 0x11, 0x1E }, { 0x0E, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0E }, { 0x1E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1E }, { 0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x1F }, { 0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x10 }, { 0x0E, 0x11, 0x10, 0x17, 0x11, 0x11, 0x0F }, { 0x11, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x11 }, { 0x0E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E }, { 0x07, 0x02, 0x02, 0x02, 0x02, 0x12, 0x0C }, { 0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11 }, { 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F }, { 0x11, 0x1B, 0x15, 0x15, 0x11, 0x11, 0x11 }, { 0x11, 0x11, 0x19, 0x15, 0x13, 0x11, 0x11 }, { 0x0E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E }, { 0x1E, 0x11, 0x11, 0x1E, 0x10, 0x10, 0x10 }, { 0x0E, 0x11, 0x11, 0x11, 0x15, 0x12, 0x0D }, { 0x1E, 0x11, 0x11, 0x1E, 0x14, 0x12, 0x11 }, { 0x0F, 0x10, 0x10, 0x0E, 0x01, 0x01, 0x1E }, { 0x1F, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04 }, { 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E }, { 0x11, 0x11, 0x11, 0x11, 0x11, 0x0A, 0x04 }, { 0x11, 0x11, 0x11, 0x15, 0x15, 0x15, 0x0A }, { 0x11, 0x11, 0x0A, 0x04, 0x0A, 0x11, 0x11 }, { 0x11, 0x11, 0x11, 0x0A, 0x04, 0x04, 0x04 }, { 0x1F, 0x01, 0x02, 0x04, 0x08, 0x10, 0x1F }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x0E, 0x12, 0x12, 0x0F, 0x00 }, { 0x10, 0x10, 0x10, 0x10, 0x1C, 0x12, 0x1C }, { 0x00, 0x00, 0x0E, 0x10, 0x10, 0x10, 0x0E }, { 0x02, 0x02, 0x02, 0x0E, 0x12, 0x12, 0x0E }, { 0x00, 0x00, 0x0E, 0x11, 0x1E, 0x10, 0x0E }, { 0x00, 0x08, 0x0E, 0x08, 0x1C, 0x08, 0x08 }, { 0x00, 0x0F, 0x12, 0x12, 0x0E, 0x02, 0x1C }, { 0x08, 0x08, 0x08, 0x08, 0x0E, 0x0A, 0x0A }, { 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x04 }, { 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x18 }, { 0x08, 0x08, 0x0A, 0x0C, 0x0C, 0x0A, 0x09 }, { 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04 }, { 0x00, 0x00, 0x00, 0x00, 0x1B, 0x15, 0x15 }, { 0x00, 0x00, 0x00, 0x0E, 0x09, 0x09, 0x09 }, { 0x00, 0x00, 0x0E, 0x11, 0x11, 0x11, 0x0E }, { 0x00, 0x08, 0x0E, 0x0A, 0x0E, 0x08, 0x08 }, { 0x00, 0x0E, 0x12, 0x12, 0x0E, 0x02, 0x02 }, { 0x00, 0x00, 0x08, 0x0E, 0x0A, 0x08, 0x08 }, { 0x00, 0x00, 0x0F, 0x10, 0x0E, 0x01, 0x1E }, { 0x00, 0x00, 0x1F, 0x04, 0x04, 0x04, 0x04 }, { 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x0E }, { 0x00, 0x00, 0x00, 0x11, 0x11, 0x0A, 0x04 }, { 0x00, 0x00, 0x00, 0x11, 0x15, 0x15, 0x0A }, { 0x00, 0x00, 0x11, 0x0A, 0x04, 0x0A, 0x11 }, { 0x00, 0x00, 0x09, 0x09, 0x07, 0x01, 0x0F }, { 0x00, 0x00, 0x1F, 0x02, 0x04, 0x08, 0x1F }, }; static void spi_write(pin_t mosi, pin_t sck, uint8_t data) { for (int i = 7; i >= 0; i--) { pin_write(mosi, (data >> i) & 1); pin_write(sck, 1); pin_write(sck, 0); } } static uint8_t spi_read(pin_t miso, pin_t sck) { uint8_t data = 0; for (int i = 7; i >= 0; i--) { pin_write(sck, 1); data |= (pin_read(miso) << i); pin_write(sck, 0); } return data; } static void send_cmd(chip_state_t *chip, uint8_t cmd) { pin_write(chip->DC, 0); pin_write(chip->CS, 0); spi_write(chip->MOSI, chip->SCK, cmd); pin_write(chip->CS, 1); } static void send_data(chip_state_t *chip, uint8_t data) { pin_write(chip->DC, 1); pin_write(chip->CS, 0); spi_write(chip->MOSI, chip->SCK, data); pin_write(chip->CS, 1); } static void send_data16(chip_state_t *chip, uint16_t data) { send_data(chip, data >> 8); send_data(chip, data & 0xFF); } static void set_window(chip_state_t *chip, uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1) { send_cmd(chip, 0x2A); send_data16(chip, x0); send_data16(chip, x1); send_cmd(chip, 0x2B); send_data16(chip, y0); send_data16(chip, y1); } static void fill_rect(chip_state_t *chip, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color) { if (x >= 240 || y >= 320) return; if (x + w > 240) w = 240 - x; if (y + h > 320) h = 320 - y; set_window(chip, x, y, x + w - 1, y + h - 1); send_cmd(chip, 0x2C); for (int i = 0; i < w * h; i++) { send_data16(chip, color); } } static void draw_char(chip_state_t *chip, char c, uint16_t x, uint16_t y, uint16_t color) { if (c < 32 || c > 126) return; int idx = c - 32; for (int row = 0; row < FONT_HEIGHT; row++) { uint8_t bits = font_5x7[idx][row]; for (int col = 0; col < FONT_WIDTH; col++) { if (bits & (1 << (4 - col))) { set_window(chip, x + col, y + row, x + col, y + row); send_cmd(chip, 0x2C); send_data16(chip, color); } } } } static void draw_string(chip_state_t *chip, const char *str, uint16_t x, uint16_t y, uint16_t color) { uint16_t cx = x; while (*str) { draw_char(chip, *str, cx, y, color); cx += FONT_WIDTH + 1; if (cx + FONT_WIDTH > 240) { cx = x; y += FONT_HEIGHT + 2; } str++; } } static void sd_spi_write(chip_state_t *chip, uint8_t data) { pin_write(chip->SD_CS, 0); spi_write(chip->SD_MOSI, chip->SD_SCK, data); pin_write(chip->SD_CS, 1); } static uint8_t sd_spi_read(chip_state_t *chip) { pin_write(chip->SD_CS, 0); uint8_t data = spi_read(chip->SD_MISO, chip->SD_SCK); pin_write(chip->SD_CS, 1); return data; } static uint8_t sd_send_command(chip_state_t *chip, uint8_t cmd, uint32_t arg) { uint8_t response; int retry = 0; sd_spi_write(chip, 0x40 | cmd); sd_spi_write(chip, (arg >> 24) & 0xFF); sd_spi_write(chip, (arg >> 16) & 0xFF); sd_spi_write(chip, (arg >> 8) & 0xFF); sd_spi_write(chip, arg & 0xFF); if (cmd == 0) sd_spi_write(chip, 0x95); else if (cmd == 8) sd_spi_write(chip, 0x87); else sd_spi_write(chip, 0x01); while ((response = sd_spi_read(chip)) == 0xFF && retry < 10) { retry++; } return response; } static uint8_t sd_init(chip_state_t *chip) { printf("Initializing SD card...\n"); pin_write(chip->SD_CS, 1); pin_write(chip->SD_SCK, 0); for (int i = 0; i < 10; i++) { sd_spi_write(chip, 0xFF); } if (sd_send_command(chip, 0, 0) != 0x01) { printf("SD CMD0 failed\n"); return 0; } if (sd_send_command(chip, 8, 0x1AA) != 0x01) { printf("SD CMD8 failed (not SDHC/SDXC)\n"); } int timeout = 100; while (timeout-- > 0) { sd_send_command(chip, 55, 0); if (sd_send_command(chip, 41, 0x40000000) == 0) { chip->sd_initialized = 1; printf("SD card initialized successfully\n"); return 1; } } printf("SD card init timeout\n"); return 0; } static uint8_t sd_read_sector(chip_state_t *chip, uint32_t sector, uint8_t *buffer) { if (!chip->sd_initialized) { if (!sd_init(chip)) return 0; } if (sd_send_command(chip, 17, sector * 512) != 0x00) { printf("SD read command failed\n"); return 0; } int timeout = 10000; while (sd_spi_read(chip) != 0xFE && timeout-- > 0); if (timeout <= 0) { printf("SD data token timeout\n"); return 0; } for (int i = 0; i < 512; i++) { buffer[i] = sd_spi_read(chip); } sd_spi_read(chip); sd_spi_read(chip); return 1; } static uint8_t read_file(chip_state_t *chip, const char *filename, char *buffer, uint16_t max_len) { uint8_t sector_buffer[512]; uint32_t root_dir_sector = 2048; uint16_t file_cluster = 0; if (!sd_read_sector(chip, root_dir_sector, sector_buffer)) { printf("Failed to read root directory\n"); return 0; } for (int i = 0; i < 512; i += 32) { if (sector_buffer[i] == 0x00) break; if (sector_buffer[i] == 0xE5) continue; char found_name[13]; int pos = 0; for (int j = 0; j < 8; j++) { if (sector_buffer[i + j] != ' ') { found_name[pos++] = sector_buffer[i + j]; } } found_name[pos++] = '.'; for (int j = 8; j < 11; j++) { if (sector_buffer[i + j] != ' ') { found_name[pos++] = sector_buffer[i + j]; } } found_name[pos] = '\0'; if (strcmp(found_name, "PROGRAM.C") == 0) { file_cluster = (sector_buffer[i + 26] << 8) | sector_buffer[i + 27]; printf("Found %s at cluster %d\n", filename, file_cluster); break; } } if (file_cluster == 0) { printf("File %s not found\n", filename); return 0; } uint32_t data_sector = 2048 + 32 + (file_cluster - 2) * 1; if (!sd_read_sector(chip, data_sector, sector_buffer)) { printf("Failed to read file data\n"); return 0; } uint16_t len = 0; while (len < max_len - 1 && sector_buffer[len] != 0 && sector_buffer[len] != 0x1A) { buffer[len] = sector_buffer[len]; len++; } buffer[len] = '\0'; printf("Read %d bytes from %s\n", len, filename); return 1; } static variable_t* get_variable(chip_state_t *chip, const char *name) { for (int i = 0; i < chip->var_count; i++) { if (strcmp(chip->variables[i].name, name) == 0) { return &chip->variables[i]; } } if (chip->var_count < 32) { strcpy(chip->variables[chip->var_count].name, name); chip->variables[chip->var_count].value = 0; chip->var_count++; return &chip->variables[chip->var_count - 1]; } return NULL; } static int parse_number(const char **str) { int result = 0; while (**str >= '0' && **str <= '9') { result = result * 10 + (**str - '0'); (*str)++; } return result; } static void parse_identifier(const char **str, char *buf, int max_len) { int i = 0; while ((**str >= 'a' && **str <= 'z') || (**str >= 'A' && **str <= 'Z') || (**str >= '0' && **str <= '9') || **str == '_') { if (i < max_len - 1) { buf[i++] = **str; } (*str)++; } buf[i] = '\0'; } static void skip_whitespace(const char **str) { while (**str == ' ' || **str == '\t' || **str == '\n' || **str == '\r') { (*str)++; } } static int eval_expression(chip_state_t *chip, const char **str) { skip_whitespace(str); int result = 0; if (**str >= '0' && **str <= '9') { result = parse_number(str); } else if ((**str >= 'a' && **str <= 'z') || (**str >= 'A' && **str <= 'Z')) { char var_name[16]; parse_identifier(str, var_name, sizeof(var_name)); variable_t *var = get_variable(chip, var_name); result = var ? var->value : 0; } else if (**str == '(') { (*str)++; result = eval_expression(chip, str); skip_whitespace(str); if (**str == ')') (*str)++; else { chip->error = 1; strcpy(chip->error_msg, "Expected )"); return 0; } } else { chip->error = 1; strcpy(chip->error_msg, "Invalid expression start"); return 0; } while (1) { skip_whitespace(str); char op = **str; if (op != '+' && op != '-' && op != '*' && op != '/') { break; } (*str)++; skip_whitespace(str); int next_value = 0; if (**str >= '0' && **str <= '9') { next_value = parse_number(str); } else if ((**str >= 'a' && **str <= 'z') || (**str >= 'A' && **str <= 'Z')) { char var_name[16]; parse_identifier(str, var_name, sizeof(var_name)); variable_t *var = get_variable(chip, var_name); next_value = var ? var->value : 0; } else if (**str == '(') { (*str)++; next_value = eval_expression(chip, str); skip_whitespace(str); if (**str == ')') (*str)++; else { chip->error = 1; strcpy(chip->error_msg, "Expected )"); return 0; } } else { chip->error = 1; strcpy(chip->error_msg, "Expected value after operator"); return 0; } switch (op) { case '+': result += next_value; break; case '-': result -= next_value; break; case '*': result *= next_value; break; case '/': if (next_value != 0) { result /= next_value; } else { chip->error = 1; strcpy(chip->error_msg, "Division by zero"); return 0; } break; } } return result; } static void run_statement(chip_state_t *chip, const char **program) { skip_whitespace(program); if (**program == '\0') { return; } if (strncmp(*program, " while (**program && **program != '\n') (*program)++; if (**program == '\n') (*program)++; return; } if (strncmp(*program, "print(", 6) == 0) { *program += 6; int value = eval_expression(chip, program); chip->output_value = value; if (chip->output_count < 10) { sprintf(chip->program_outputs[chip->output_count], "OUT: %d", value); chip->output_count++; } printf("PROGRAM OUTPUT: %d\n", value); skip_whitespace(program); if (**program != ')') { chip->error = 1; strcpy(chip->error_msg, "Expected )"); return; } (*program)++; skip_whitespace(program); if (**program != ';') { chip->error = 1; strcpy(chip->error_msg, "Expected ;"); } else { (*program)++; } return; } if ((**program >= 'a' && **program <= 'z') || (**program >= 'A' && **program <= 'Z')) { char var_name[16]; parse_identifier(program, var_name, sizeof(var_name)); skip_whitespace(program); if (**program != '=') { chip->error = 1; strcpy(chip->error_msg, "Expected ="); return; } (*program)++; int value = eval_expression(chip, program); variable_t *var = get_variable(chip, var_name); if (var) { var->value = value; if (chip->output_count < 10) { sprintf(chip->program_outputs[chip->output_count], "%s = %d", var_name, value); chip->output_count++; } } skip_whitespace(program); if (**program != ';') { chip->error = 1; strcpy(chip->error_msg, "Expected ;"); } else { (*program)++; } return; } if (**program == ';') { (*program)++; return; } chip->error = 1; if (**program) { sprintf(chip->error_msg, "Unexpected: '%c'", **program); } else { strcpy(chip->error_msg, "Unexpected end"); } } static void load_program_c(chip_state_t *chip) { printf("Loading program.c from SD card...\n"); chip->program_buffer[0] = '\0'; chip->program_loaded = 0; if (pin_read(chip->SD_CD) == 0) { chip->sd_card_present = 1; printf("SD card detected\n"); if (read_file(chip, "program.c", chip->program_buffer, sizeof(chip->program_buffer) - 1)) { chip->program_loaded = 1; printf("Successfully loaded program.c (%lu bytes)\n", (unsigned long)strlen(chip->program_buffer)); return; } } else { chip->sd_card_present = 0; printf("No SD card detected\n"); } printf("Using default program\n"); const char *default_program = " "x = 10;\n" "print(x);\n" "y = 20;\n" "sum = x + y;\n" "print(sum);\n"; strcpy(chip->program_buffer, default_program); chip->program_loaded = 1; } static void run_program_c(chip_state_t *chip) { printf("\n=== RUNNING program.c ===\n"); chip->running = 1; chip->error = 0; chip->output_value = 0; chip->var_count = 0; chip->output_count = 0; memset(chip->variables, 0, sizeof(chip->variables)); memset(chip->program_outputs, 0, sizeof(chip->program_outputs)); fill_rect(chip, 0, 0, 240, 320, COLOR_BLACK); draw_string(chip, "EXECUTING PROGRAM.C", 30, 140, COLOR_YELLOW); draw_string(chip, "Please wait...", 70, 160, COLOR_CYAN); load_program_c(chip); if (!chip->program_loaded) { chip->error = 1; strcpy(chip->error_msg, "Failed to load program"); chip->running = 0; return; } const char *ptr = chip->program_buffer; while (*ptr && !chip->error) { run_statement(chip, &ptr); } chip->running = 0; if (chip->error) { printf("ERROR: %s\n", chip->error_msg); } else { printf("Program finished successfully\n"); printf("Final output: %d\n", chip->output_value); } } static void update_display(chip_state_t *chip) { fill_rect(chip, 0, 0, 240, 320, COLOR_BLACK); draw_string(chip, "C PROGRAM RUNNER", 50, 10, COLOR_GREEN); draw_string(chip, "================", 50, 20, COLOR_CYAN); if (chip->sd_card_present) { draw_string(chip, "SD CARD: PRESENT", 20, 40, COLOR_GREEN); } else { draw_string(chip, "SD CARD: NOT FOUND", 20, 40, COLOR_RED); } draw_string(chip, "FILE: program.c", 20, 60, COLOR_WHITE); if (chip->running) { draw_string(chip, "STATUS: RUNNING", 20, 80, COLOR_YELLOW); } else if (chip->error) { draw_string(chip, "STATUS: ERROR", 20, 80, COLOR_RED); draw_string(chip, chip->error_msg, 20, 100, COLOR_RED); } else { draw_string(chip, "STATUS: READY", 20, 80, COLOR_GREEN); draw_string(chip, "Press RUN button", 20, 100, COLOR_CYAN); } draw_string(chip, "PROGRAM OUTPUTS:", 20, 130, COLOR_MAGENTA); int y_pos = 150; for (int i = 0; i < chip->output_count && i < 6; i++) { draw_string(chip, chip->program_outputs[i], 30, y_pos, COLOR_WHITE); y_pos += 20; } if (chip->output_count == 0 && !chip->running) { draw_string(chip, "No outputs yet", 30, 150, COLOR_GRAY); } draw_string(chip, "VARIABLES:", 20, 250, COLOR_CYAN); y_pos = 270; for (int i = 0; i < chip->var_count && i < 3; i++) { char var_str[32]; sprintf(var_str, "%s = %d", chip->variables[i].name, chip->variables[i].value); draw_string(chip, var_str, 30, y_pos, COLOR_YELLOW); y_pos += 15; } if (!chip->running) { draw_string(chip, "Press RUN_BTN to execute", 20, 310, COLOR_WHITE); } } static void program_timer_callback(void *user_data) { chip_state_t *chip = (chip_state_t*)user_data; chip->running = 0; update_display(chip); } static void main_timer_callback(void *user_data) { chip_state_t *chip = (chip_state_t*)user_data; uint8_t sd_present = (pin_read(chip->SD_CD) == 0); if (sd_present != chip->sd_card_present) { chip->sd_card_present = sd_present; if (!chip->running) { update_display(chip); } } uint8_t btn_state = pin_read(chip->RUN_BTN); if (btn_state == 0 && !chip->btn_pressed && !chip->btn_debounce && !chip->running) { chip->btn_debounce = 1; chip->btn_pressed = 1; printf("RUN button pressed - executing program\n"); run_program_c(chip); const timer_config_t program_config = { .callback = program_timer_callback, .user_data = chip, }; chip->program_timer = timer_init(&program_config); timer_start(chip->program_timer, 100000, 1); const timer_config_t debounce_config = { .callback = NULL, .user_data = chip, }; chip->btn_debounce_timer = timer_init(&debounce_config); timer_start(chip->btn_debounce_timer, 50000, 1); } else if (btn_state == 1 && chip->btn_pressed) { chip->btn_pressed = 0; } timer_start(chip->timer, 50000, 0); } static void display_timer_callback(void *user_data) { chip_state_t *chip = (chip_state_t*)user_data; if (chip->btn_debounce) { chip->btn_debounce = 0; } if (!chip->running) { update_display(chip); } timer_start(chip->display_timer, 500000, 0); } static void run_btn_callback(void *user_data, pin_t pin, uint32_t value) { chip_state_t *chip = (chip_state_t*)user_data; if (value == 0 && !chip->running && !chip->btn_debounce) { chip->btn_debounce = 1; printf("RUN button pressed via callback\n"); run_program_c(chip); const timer_config_t program_config = { .callback = program_timer_callback, .user_data = chip, }; chip->program_timer = timer_init(&program_config); timer_start(chip->program_timer, 100000, 1); const timer_config_t debounce_config = { .callback = NULL, .user_data = chip, }; chip->btn_debounce_timer = timer_init(&debounce_config); timer_start(chip->btn_debounce_timer, 50000, 1); } } static void init_display(chip_state_t *chip) { printf("Initializing ILI9341...\n"); pin_write(chip->RST, 0); timer_t delay = timer_init(NULL); timer_start(delay, 10000, 0); pin_write(chip->RST, 1); timer_start(delay, 100000, 0); send_cmd(chip, 0x01); timer_start(delay, 5000, 0); send_cmd(chip, 0x11); timer_start(delay, 120000, 0); send_cmd(chip, 0x3A); send_data(chip, 0x55); send_cmd(chip, 0x36); send_data(chip, 0x48); send_cmd(chip, 0x29); pin_write(chip->LED, 1); printf("Display ready\n"); } static void init_callback(void *user_data) { chip_state_t *chip = (chip_state_t*)user_data; init_display(chip); chip->sd_card_present = (pin_read(chip->SD_CD) == 0); if (chip->sd_card_present) { printf("SD card detected on startup\n"); sd_init(chip); } load_program_c(chip); update_display(chip); const timer_config_t main_config = { .callback = main_timer_callback, .user_data = chip, }; chip->timer = timer_init(&main_config); timer_start(chip->timer, 100000, 0); const timer_config_t display_config = { .callback = display_timer_callback, .user_data = chip, }; chip->display_timer = timer_init(&display_config); timer_start(chip->display_timer, 1000000, 0); printf("System ready. Press RUN_BTN to execute program.c\n"); } void chip_init(void) { chip_state_t *chip = malloc(sizeof(chip_state_t)); memset(chip, 0, sizeof(chip_state_t)); printf("=================================\n"); printf(" ILI9341 C PROGRAM RUNNER\n"); printf(" Runs program.c from SD card\n"); printf("=================================\n"); chip->VCC = pin_init("VCC", OUTPUT); chip->GND = pin_init("GND", OUTPUT); chip->CS = pin_init("CS", OUTPUT); chip->RST = pin_init("RST", OUTPUT); chip->DC = pin_init("DC", OUTPUT); chip->MOSI = pin_init("MOSI", OUTPUT); chip->SCK = pin_init("SCK", OUTPUT); chip->LED = pin_init("LED", OUTPUT); chip->MISO = pin_init("MISO", INPUT); chip->SD_CS = pin_init("SD_CS", OUTPUT); chip->SD_MOSI = pin_init("SD_DI", OUTPUT); chip->SD_MISO = pin_init("SD_DO", INPUT); chip->SD_SCK = pin_init("SD_SCK", OUTPUT); chip->SD_CD = pin_init("SD_CD", INPUT_PULLUP); chip->RUN_BTN = pin_init("COMPILE_BUTTON", INPUT_PULLUP); pin_write(chip->VCC, 1); pin_write(chip->GND, 0); pin_write(chip->LED, 1); pin_write(chip->CS, 1); pin_write(chip->RST, 1); pin_write(chip->DC, 0); pin_write(chip->MOSI, 0); pin_write(chip->SCK, 0); pin_write(chip->SD_CS, 1); pin_write(chip->SD_MOSI, 1); pin_write(chip->SD_SCK, 0); chip->btn_pressed = 0; chip->btn_debounce = 0; chip->sd_initialized = 0; chip->sd_card_present = 0; const pin_watch_config_t btn_watch = { .edge = BOTH, .pin_change = run_btn_callback, .user_data = chip, }; pin_watch(chip->RUN_BTN, &btn_watch); chip->running = 0; chip->error = 0; chip->output_value = 0; chip->program_loaded = 0; chip->var_count = 0; chip->output_count = 0; const timer_config_t init_config = { .callback = init_callback, .user_data = chip, }; timer_t init_timer = timer_init(&init_config); timer_start(init_timer, 100000, 0); printf("System initialized. Waiting for RUN_BTN...\n"); }
    // Clock and Reset,
    input wire clk,,
    input wire rst_n,
,
    // Input Ports,
    input wire VCC,,
    input wire MISO,,
    input wire SD_MISO,,
    input wire SD_CD,,
    input wire RUN_BTN,,
,
    // Output Ports,
    output reg GND,,
    output reg CS,,
    output reg RST,,
    output reg DC,,
    output reg MOSI,,
    output reg SCK,,
    output reg LED,,
    output reg SD_CS,,
    output reg SD_MOSI,,
    output reg SD_SCK
);

    // Internal Signals
    reg [7:0] name[0:15];
    reg [15:0] value;
    reg [31:0] i;
    reg [7:0] data;
    reg [31:0] i;
    reg [31:0] i;
    reg [31:0] idx;
    reg [31:0] row;
    reg [7:0] bits;
    reg [31:0] col;
    reg [15:0] cx;
    reg [7:0] data;
    reg [31:0] retry;
    reg [31:0] i;
    reg [31:0] timeout;
    reg [31:0] timeout;
    reg [31:0] i;
    reg [31:0] root_dir_sector;
    reg [15:0] file_cluster;
    reg [31:0] i;
    reg [31:0] pos;
    reg [31:0] j;
    reg [31:0] j;
    reg [31:0] data_sector;
    reg [15:0] len;
    reg [31:0] i;
    reg [31:0] result;
    reg [31:0] i;
    reg [31:0] result;
    reg [7:0] op;
    reg [31:0] next_value;
    reg [31:0] value;
    reg [31:0] value;
    reg [31:0] y_pos;
    reg [31:0] i;
    reg [31:0] i;
    reg [7:0] sd_present;
    reg [7:0] btn_state;
    reg  program_config;
    reg  debounce_config;
    reg  program_config;
    reg  debounce_config;
    reg  delay;
    reg  main_config;
    reg  display_config;
    reg  btn_watch;
    reg  init_config;
    reg  init_timer;

    // ============================================
    // Clock and Reset Domain
    // ============================================
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Reset all registers
    // ============================================
    // SPI Master Interface
    // ============================================
    reg [7:0] spi_tx_data;
    reg [7:0] spi_rx_data;
    reg spi_start;
    wire spi_busy;
    reg [2:0] spi_bit_counter;
    reg spi_sck_reg;
    reg spi_mosi_reg;
    
    assign SCK = spi_sck_reg;
    assign MOSI = spi_mosi_reg;
    
    // SPI state machine
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            spi_bit_counter <= 3'd0;
            spi_sck_reg <= 1'b0;
            spi_mosi_reg <= 1'b0;
            spi_rx_data <= 8'd0;
            spi_busy <= 1'b0;
        end else begin
            if (spi_start && !spi_busy) begin
                spi_busy <= 1'b1;
                spi_bit_counter <= 3'd0;
            end
            
            if (spi_busy) begin
                if (spi_bit_counter < 3'd8) begin
                    spi_sck_reg <= ~spi_sck_reg;
                    if (!spi_sck_reg) begin
                        // On falling edge, set MOSI
                        spi_mosi_reg <= spi_tx_data[7 - spi_bit_counter];
                    end else begin
                        // On rising edge, sample MISO
                        spi_rx_data[7 - spi_bit_counter] <= MISO;
                        spi_bit_counter <= spi_bit_counter + 1;
                    end
                end else begin
                    // Transmission complete
                    spi_busy <= 1'b0;
                    spi_sck_reg <= 1'b0;
                end
            end
        end
    end

    // ============================================
    // Display Controller Interface
    // ============================================
    reg display_start;
    reg [15:0] display_x;
    reg [15:0] display_y;
    reg [15:0] display_color;
    wire display_busy;
    
    // Display controller state machine
    reg [3:0] display_state;
    reg [15:0] display_counter;
    
    localparam [3:0] 
        DISPLAY_IDLE = 4'd0,
        DISPLAY_INIT = 4'd1,
        DISPLAY_SET_WINDOW = 4'd2,
        DISPLAY_SEND_PIXEL = 4'd3,
        DISPLAY_WAIT = 4'd4;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            display_state <= DISPLAY_IDLE;
            DC <= 1'b0;
            CS <= 1'b1;
        end else begin
            case (display_state)
                DISPLAY_IDLE: begin
                    if (display_start) begin
                        display_state <= DISPLAY_INIT;
                        CS <= 1'b0;
                    end
                end
                DISPLAY_INIT: begin
                    // Send initialization commands
                    // Implementation depends on specific display
                    display_state <= DISPLAY_SET_WINDOW;
                end
                // ... other states
            endcase
        end
    end

    // ============================================
    // SD Card Interface
    // ============================================
    reg sd_read_start;
    reg [31:0] sd_sector_addr;
    reg [7:0] sd_buffer [0:511];
    wire sd_read_done;
    wire sd_card_present;
    
    // SD card state machine
    reg [4:0] sd_state;
    reg [7:0] sd_cmd_counter;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            sd_state <= 5'd0;
            SD_CS <= 1'b1;
        end else begin
            case (sd_state)
                0: begin // IDLE
                    if (sd_read_start) begin
                        sd_state <= 1;
                        SD_CS <= 1'b0;
                    end
                end
                1: begin // SEND_CMD
                    // Send read command
                    // Implementation depends on SD card type
                    sd_state <= 2;
                end
                // ... other states
            endcase
        end
    end

    // ============================================
    // Timer System
    // ============================================
    reg [31:0] timer_counter;
    reg [31:0] timer_period;
    reg timer_enable;
    wire timer_interrupt;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            timer_counter <= 32'd0;
            timer_interrupt <= 1'b0;
        end else if (timer_enable) begin
            if (timer_counter >= timer_period) begin
                timer_counter <= 32'd0;
                timer_interrupt <= 1'b1;
            end else begin
                timer_counter <= timer_counter + 1;
                timer_interrupt <= 1'b0;
            end
        end
    end
    // ============================================
    // Main State Machine
    // ============================================
    localparam [1:0]
        IDLE = 2'd0,
        INIT = 2'd1,
        RUN = 2'd2,
        DONE = 2'd3;
    
    reg [1:0] current_state;
    reg [1:0] next_state;
    
    // State register
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            current_state <= IDLE;
        end else begin
            current_state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        next_state = current_state;
        case (current_state)
            IDLE: begin
                if (/* start condition */) next_state = INIT;
            end
            INIT: begin
                if (/* init done */) next_state = RUN;
            end
            RUN: begin
                if (/* run complete */) next_state = DONE;
            end
            DONE: begin
                next_state = IDLE;
            end
            default: next_state = IDLE;
        endcase
    end
    // ============================================
    // Main Logic
    // ============================================
    
    // Add your main application logic here
    // This section combines all interfaces and state machines
    
    // Example: Process button inputs
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Reset button logic
        end else begin
            // Button debouncing and processing
            case (current_state)
                IDLE: begin
                    // Wait for button press
                end
                // ... other states
            endcase
        end
    end
    
    // End of always block for reset
        end
endmodule
