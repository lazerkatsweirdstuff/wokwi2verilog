`timescale 1ns / 1ps
// ============================================================================
// Generated by Wokwi2Verilog
// Module: example
// ============================================================================

module example (
    // Clock and Reset
    input wire clk,
    input wire rst_n

    // Input Pins
    input wire MISO,
    input wire SD_MISO,
    input wire SD_CD,
    input wire RUN_BTN,

    // Output Pins
    output reg CS,
    output reg RST,
    output reg DC,
    output reg MOSI,
    output reg SCK,
    output reg LED,
    output reg SD_CS,
    output reg SD_MOSI,
    output reg SD_SCK
);

    // Parameters from #defines
    parameter COLOR_BLACK = 16'h0000;
    parameter COLOR_BLUE = 16'h001F;
    parameter COLOR_RED = 16'hF800;
    parameter COLOR_GREEN = 16'h07E0;
    parameter COLOR_YELLOW = 16'hFFE0;
    parameter COLOR_WHITE = 16'hFFFF;
    parameter COLOR_CYAN = 16'h07FF;
    parameter COLOR_MAGENTA = 16'hF81F;
    parameter COLOR_GRAY = 16'h8410;
    parameter COLOR_ORANGE = 16'hFD20;
    parameter FONT_WIDTH = 5;
    parameter FONT_HEIGHT = 7;
    parameter FONT_SPACING = 1;

    // Internal Signals
    reg [7:0] btn_pressed;
    reg [7:0] btn_debounce;
    reg [7:0] running;
    reg [7:0] error;
    reg [7:0] error_msg[0:63];
    reg [15:0] output_value;
    reg  variables[0:31];
    reg [7:0] var_count;
    reg [7:0] program_buffer[0:4095];
    reg [7:0] program_loaded;
    reg [7:0] output_count;
    reg [7:0] sd_initialized;
    reg [7:0] sd_card_present;
    reg  timer;
    reg  display_timer;
    reg  btn_debounce_timer;
    reg  program_timer;
    reg [31:0] counter;
    reg [7:0] spi_tx_data;
    reg [7:0] spi_rx_data;
    reg spi_start;
    wire spi_busy;
    reg [2:0] spi_bit_counter;
    reg spi_sck;
    reg spi_mosi;
    reg [15:0] display_x;
    reg [15:0] display_y;
    reg [15:0] display_color;
    reg display_start;
    wire display_busy;
    reg [2:0] display_state;
    reg [31:0] sd_sector;
    reg [7:0] sd_buffer [0:511];
    reg sd_read_start;
    wire sd_read_done;
    wire sd_card_present;
    reg [4:0] sd_state;

    // Power Pin Assignments
    assign VCC = 1'b1;
    assign GND = 1'b0;

    // ====================================================
    // Clock and Reset
    // ====================================================
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            counter <= 32'd0;
            // Reset other registers here
        end else begin
            counter <= counter + 1;
        end
    end

    // ====================================================
    // SPI Master Interface
    // ====================================================
    assign SCK = spi_sck;
    assign MOSI = spi_mosi;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            spi_bit_counter <= 3'd0;
            spi_sck <= 1'b0;
            spi_mosi <= 1'b0;
            spi_rx_data <= 8'd0;
        end else begin
            if (spi_start && !spi_busy) begin
                spi_bit_counter <= 3'd0;
                spi_sck <= 1'b0;
            end
            
            if (spi_bit_counter < 3'd8) begin
                spi_sck <= ~spi_sck;
                if (!spi_sck) begin
                    // Falling edge - set MOSI
                    spi_mosi <= spi_tx_data[7 - spi_bit_counter];
                end else begin
                    // Rising edge - sample MISO
                    spi_rx_data[7 - spi_bit_counter] <= MISO;
                    spi_bit_counter <= spi_bit_counter + 1;
                end
            end
        end
    end
    
    assign spi_busy = (spi_bit_counter < 3'd8);

    // ====================================================
    // Display Controller
    // ====================================================
    localparam [2:0] 
        DISP_IDLE   = 3'd0,
        DISP_CMD    = 3'd1,
        DISP_DATA   = 3'd2;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            display_state <= DISP_IDLE;
            CS <= 1'b1;
            DC <= 1'b0;
            display_start <= 1'b0;
        end else begin
            case (display_state)
                DISP_IDLE: begin
                    if (display_start) begin
                        display_state <= DISP_CMD;
                        CS <= 1'b0;
                    end
                end
                DISP_CMD: begin
                    DC <= 1'b0;
                    spi_tx_data <= 8'h2A;  // Column address set
                    spi_start <= 1'b1;
                    display_state <= DISP_DATA;
                end
                DISP_DATA: begin
                    DC <= 1'b1;
                    // Send display data
                    if (!spi_busy) begin
                        display_state <= DISP_IDLE;
                        CS <= 1'b1;
                    end
                end
            endcase
        end
    end
    
    assign display_busy = (display_state != DISP_IDLE);

    // ====================================================
    // SD Card Controller
    // ====================================================
    assign sd_card_present = ~SD_CD;
    
    localparam [4:0]
        SD_IDLE     = 5'd0,
        SD_INIT     = 5'd1,
        SD_READ_CMD = 5'd2,
        SD_READ_WAIT = 5'd3;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            sd_state <= SD_IDLE;
            SD_CS <= 1'b1;
        end else begin
            case (sd_state)
                SD_IDLE: begin
                    if (sd_read_start && sd_card_present) begin
                        sd_state <= SD_INIT;
                        SD_CS <= 1'b0;
                    end
                end
                SD_INIT: begin
                    // Initialize SD card
                    sd_state <= SD_READ_CMD;
                end
                SD_READ_CMD: begin
                    // Send read command
                    sd_state <= SD_READ_WAIT;
                end
                SD_READ_WAIT: begin
                    // Wait for data
                    if (counter[15:0] == 16'hFFFF) begin
                        sd_state <= SD_IDLE;
                        SD_CS <= 1'b1;
                    end
                end
            endcase
        end
    end
    
    assign sd_read_done = (sd_state == SD_IDLE);

    // ====================================================
    // Main State Machine
    // ====================================================
    localparam [2:0]
        STATE_IDLE      = 3'd0,
        STATE_INIT      = 3'd1,
        STATE_RUN       = 3'd2,
        STATE_LOAD_SD   = 3'd3,
        STATE_DISPLAY   = 3'd4,
        STATE_DONE      = 3'd5;
    
    reg [2:0] current_state;
    reg [2:0] next_state;
    
    // State register
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            current_state <= STATE_IDLE;
        end else begin
            current_state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        next_state = current_state;
        case (current_state)
            STATE_IDLE: begin
                if (RUN_BTN == 1'b0) begin
                    next_state = STATE_INIT;
                end
            end
            STATE_INIT: begin
                next_state = STATE_RUN;
            end
            STATE_RUN: begin
                next_state = STATE_LOAD_SD;
            end
            STATE_LOAD_SD: begin
                if (sd_read_done) begin
                    next_state = STATE_DISPLAY;
                end
            end
            STATE_DISPLAY: begin
                if (!display_busy) begin
                    next_state = STATE_DONE;
                end
            end
            STATE_DONE: begin
                next_state = STATE_IDLE;
            end
            default: next_state = STATE_IDLE;
        endcase
    end

    // ====================================================
    // Main Application Logic
    // ====================================================
    
    // Button debouncing
    reg [19:0] btn_counter;
    reg btn_pressed;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            btn_counter <= 20'd0;
            btn_pressed <= 1'b0;
        end else begin
            if (RUN_BTN == 1'b0) begin
                if (btn_counter < 20'd1000000) begin
                    btn_counter <= btn_counter + 1;
                end else begin
                    btn_pressed <= 1'b1;
                end
            end else begin
                btn_counter <= 20'd0;
                btn_pressed <= 1'b0;
            end
        end
    end
    
    // LED control
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            LED <= 1'b0;
            RST <= 1'b1;
        end else begin
            case (current_state)
                STATE_IDLE: LED <= 1'b0;
                STATE_INIT: LED <= 1'b1;
                STATE_RUN: LED <= counter[23];  // Slow blink
                STATE_LOAD_SD: LED <= ~LED;  // Fast blink
                STATE_DISPLAY: LED <= 1'b1;
                STATE_DONE: LED <= 1'b0;
                default: LED <= 1'b0;
            endcase
            
            // Display reset control
            RST <= (current_state != STATE_INIT);
        end
    end
    
    // Control signals
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            display_start <= 1'b0;
            sd_read_start <= 1'b0;
        end else begin
            display_start <= (current_state == STATE_DISPLAY);
            sd_read_start <= (current_state == STATE_LOAD_SD);
        end
    end

endmodule