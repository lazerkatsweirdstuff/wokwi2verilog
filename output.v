`timescale 1ns / 1ps
// ============================================================
// Generated by Wokwi2Verilog - I2C OLED Version
// Module: example
// Display: SH1107 OLED with I2C interface
// ============================================================

module example (
    // Clock and Reset
    input wire clk,
    input wire rst_n,

    // Button Inputs
    input wire sda_pin,
    input wire up_pin,
    input wire down_pin,
    input wire left_pin,
    input wire right_pin,
    input wire Abutton,
    input wire Bbutton,

    // Other Pins
    output reg scl_pin,
    output reg vcc_pin,
    output reg gnd_pin
);

    // Display Parameters
    parameter SH1107_CONTROL_CO = 8'h80;
    parameter SH1107_CONTROL_DC = 8'h40;
    parameter OLED_WIDTH = 128;
    parameter OLED_HEIGHT = 64;
    parameter PIXELS_PER_SECOND = 32'd005;
    parameter BUTTON_HEIGHT = 12;
    parameter BUTTON_BORDER = 2;
    parameter MAX_BUTTONS = 10;

    // Internal Signals
    reg [31:0] counter;
    reg [6:0] i2c_address;
    reg i2c_start_sent;
    reg i2c_stop_sent;
    reg [7:0] i2c_data_out;
    reg i2c_write_active;
    reg [2:0] i2c_bit_counter;
    reg [7:0] oled_command;
    reg [15:0] pixel_x;
    reg [15:0] pixel_y;
    reg [15:0] old_pixel_x;
    reg [15:0] old_pixel_y;
    reg cursor_inverted;
    reg [1:0] current_screen;
    reg a_button_was_pressed;
    reg [4:0] button_count;
    // Button structures
    reg [15:0] button_start_x [0:9];
    reg [15:0] button_start_y [0:9];
    reg [15:0] button_width [0:9];
    reg [7:0] button_page [0:9];
    reg button_is_filled [0:9];
    // Font ROM (5x7 font)
    reg [7:0] font_5x7 [0:27][0:4];

    // ============================================
    // Clock and Reset
    // ============================================
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            counter <= 32'd0;
            pixel_x <= 16'd64;  // Center of display
            pixel_y <= 16'd32;
            old_pixel_x <= 16'd64;
            old_pixel_y <= 16'd32;
            cursor_inverted <= 1'b0;
            current_screen <= 2'b00;  // SCREEN_LOCKED
            a_button_was_pressed <= 1'b0;
            button_count <= 5'd0;
            i2c_address <= 7'h3C;  // SH1107 default address
        end else begin
            counter <= counter + 1;
        end
    end

    // ============================================
    // I2C Master Interface
    // ============================================
    reg i2c_scl;
    reg i2c_sda;
    
    assign SCL = i2c_scl;
    assign SDA = i2c_sda;
    
    // I2C state machine
    reg [2:0] i2c_state;
    localparam [2:0]
        I2C_IDLE      = 3'd0,
        I2C_START     = 3'd1,
        I2C_ADDR      = 3'd2,
        I2C_DATA      = 3'd3,
        I2C_STOP      = 3'd4;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            i2c_state <= I2C_IDLE;
            i2c_scl <= 1'b1;
            i2c_sda <= 1'b1;
            i2c_bit_counter <= 3'd0;
            i2c_write_active <= 1'b0;
        end else begin
            case (i2c_state)
                I2C_IDLE: begin
                    if (i2c_write_active) begin
                        i2c_state <= I2C_START;
                        i2c_scl <= 1'b1;
                        i2c_sda <= 1'b1;
                    end
                end
                I2C_START: begin
                    i2c_sda <= 1'b0;
                    i2c_state <= I2C_ADDR;
                    i2c_bit_counter <= 3'd7;
                end
                I2C_ADDR: begin
                    // Send 7-bit address + write bit (0)
                    i2c_scl <= 1'b0;
                    i2c_sda <= {i2c_address, 1'b0}[i2c_bit_counter];
                    if (counter[0]) begin
                        i2c_scl <= 1'b1;
                        if (i2c_bit_counter == 3'd0) begin
                            i2c_state <= I2C_DATA;
                            i2c_bit_counter <= 3'd7;
                        end else begin
                            i2c_bit_counter <= i2c_bit_counter - 1;
                        end
                    end
                end
                I2C_DATA: begin
                    i2c_scl <= 1'b0;
                    i2c_sda <= i2c_data_out[i2c_bit_counter];
                    if (counter[0]) begin
                        i2c_scl <= 1'b1;
                        if (i2c_bit_counter == 3'd0) begin
                            i2c_state <= I2C_STOP;
                        end else begin
                            i2c_bit_counter <= i2c_bit_counter - 1;
                        end
                    end
                end
                I2C_STOP: begin
                    i2c_scl <= 1'b0;
                    i2c_sda <= 1'b0;
                    if (counter[0]) begin
                        i2c_scl <= 1'b1;
                        i2c_sda <= 1'b1;
                        i2c_state <= I2C_IDLE;
                        i2c_write_active <= 1'b0;
                    end
                end
            endcase
        end
    end

    // ============================================
    // OLED Display Controller
    // ============================================
    reg [3:0] oled_state;
    localparam [3:0]
        OLED_IDLE     = 4'd0,
        OLED_INIT     = 4'd1,
        OLED_CLEAR    = 4'd2,
        OLED_DRAW     = 4'd3,
        OLED_UPDATE   = 4'd4;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            oled_state <= OLED_INIT;
            i2c_write_active <= 1'b0;
            i2c_data_out <= 8'h00;
        end else begin
            case (oled_state)
                OLED_INIT: begin
                    // Send initialization commands
                    if (!i2c_write_active) begin
                        i2c_data_out <= 8'hAE;  // Display off
                        i2c_write_active <= 1'b1;
                        oled_state <= OLED_CLEAR;
                    end
                end
                OLED_CLEAR: begin
                    // Clear display
                    if (!i2c_write_active && counter[10:0] == 11'h7FF) begin
                        i2c_data_out <= 8'h00;  // Clear data
                        i2c_write_active <= 1'b1;
                        if (counter[15:0] == 16'hFFFF) begin
                            oled_state <= OLED_DRAW;
                        end
                    end
                end
                OLED_DRAW: begin
                    // Drawing logic would go here
                    oled_state <= OLED_UPDATE;
                end
                OLED_UPDATE: begin
                    // Update display
                    if (counter[19:0] == 20'hFFFFF) begin
                        oled_state <= OLED_DRAW;
                    end
                end
            endcase
        end
    end
    
    // Framebuffer update logic
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            framebuffer <= 1024'h0;  // 128x64/8 = 1024 bytes
        end else begin
            // Update pixel at cursor position
            if (pixel_x != old_pixel_x || pixel_y != old_pixel_y) begin
                // Clear old pixel
                // Set new pixel
                old_pixel_x <= pixel_x;
                old_pixel_y <= pixel_y;
            end
        end
    end

    // ============================================
    // Button Input Processing
    // ============================================
    reg up_pressed;
    reg down_pressed;
    reg left_pressed;
    reg right_pressed;
    reg a_pressed;
    reg b_pressed;
    
    // Button debouncing
    reg [19:0] up_debounce;
    reg [19:0] down_debounce;
    reg [19:0] left_debounce;
    reg [19:0] right_debounce;
    reg [19:0] a_debounce;
    reg [19:0] b_debounce;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            up_pressed <= 1'b0;
            down_pressed <= 1'b0;
            left_pressed <= 1'b0;
            right_pressed <= 1'b0;
            a_pressed <= 1'b0;
            b_pressed <= 1'b0;
            up_debounce <= 20'd0;
            down_debounce <= 20'd0;
            left_debounce <= 20'd0;
            right_debounce <= 20'd0;
            a_debounce <= 20'd0;
            b_debounce <= 20'd0;
        end else begin
            // Debounce Up button
            if (!Up) begin
                if (up_debounce < 20'd1000000) up_debounce <= up_debounce + 1;
                else up_pressed <= 1'b1;
            end else begin
                up_debounce <= 20'd0;
                up_pressed <= 1'b0;
            end
            
            // Debounce Down button
            if (!Down) begin
                if (down_debounce < 20'd1000000) down_debounce <= down_debounce + 1;
                else down_pressed <= 1'b1;
            end else begin
                down_debounce <= 20'd0;
                down_pressed <= 1'b0;
            end
            
            // Debounce Left button
            if (!Left) begin
                if (left_debounce < 20'd1000000) left_debounce <= left_debounce + 1;
                else left_pressed <= 1'b1;
            end else begin
                left_debounce <= 20'd0;
                left_pressed <= 1'b0;
            end
            
            // Debounce Right button
            if (!Right) begin
                if (right_debounce < 20'd1000000) right_debounce <= right_debounce + 1;
                else right_pressed <= 1'b1;
            end else begin
                right_debounce <= 20'd0;
                right_pressed <= 1'b0;
            end
            
            // Debounce A button
            if (!A) begin
                if (a_debounce < 20'd1000000) a_debounce <= a_debounce + 1;
                else a_pressed <= 1'b1;
            end else begin
                a_debounce <= 20'd0;
                a_pressed <= 1'b0;
            end
            
            // Debounce B button
            if (!B) begin
                if (b_debounce < 20'd1000000) b_debounce <= b_debounce + 1;
                else b_pressed <= 1'b1;
            end else begin
                b_debounce <= 20'd0;
                b_pressed <= 1'b0;
            end
        end
    end
    
    // Cursor movement
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Already handled in reset
        end else begin
            if (up_pressed && pixel_y > 0) pixel_y <= pixel_y - 1;
            if (down_pressed && pixel_y < OLED_HEIGHT - 1) pixel_y <= pixel_y + 1;
            if (left_pressed && pixel_x > 0) pixel_x <= pixel_x - 1;
            if (right_pressed && pixel_x < OLED_WIDTH - 1) pixel_x <= pixel_x + 1;
        end
    end

    // ============================================
    // Screen State Machine
    // ============================================
    localparam [1:0]
        SCREEN_LOCKED = 2'b00,
        SCREEN_HOME   = 2'b01,
        SCREEN_MENU   = 2'b10;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            current_screen <= SCREEN_LOCKED;
        end else begin
            case (current_screen)
                SCREEN_LOCKED: begin
                    if (a_pressed && !a_button_was_pressed) begin
                        // Check if cursor is on "unlock" button
                        // For now, always go to HOME when A is pressed
                        current_screen <= SCREEN_HOME;
                        a_button_was_pressed <= 1'b1;
                    end
                end
                SCREEN_HOME: begin
                    // Home screen logic
                    if (b_pressed) begin
                        current_screen <= SCREEN_MENU;
                    end
                end
                SCREEN_MENU: begin
                    // Menu screen logic
                    if (b_pressed) begin
                        current_screen <= SCREEN_HOME;
                    end
                end
            endcase
            
            if (!a_pressed) begin
                a_button_was_pressed <= 1'b0;
            end
        end
    end

    // ============================================
    // Main Application Logic
    // ============================================
    
    // Button drawing logic
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Initialize first button (unlock)
            button_start_x[0] <= 16'd7;   // x position
            button_start_y[0] <= 16'd46;  // y position (page 6 * 8 - 2)
            button_width[0] <= 16'd36;    // text width + 8
            button_page[0] <= 8'd6;       // page number
            button_is_filled[0] <= 1'b0;
            button_count <= 5'd1;
        end else begin
            // Update button fill based on cursor position
            if (current_screen == SCREEN_LOCKED) begin
                // Check if cursor is over button 0
                if (pixel_x >= button_start_x[0] && 
                    pixel_x < button_start_x[0] + button_width[0] &&
                    pixel_y >= button_start_y[0] && 
                    pixel_y < button_start_y[0] + BUTTON_HEIGHT) begin
                    button_is_filled[0] <= 1'b1;
                    cursor_inverted <= 1'b1;
                end else begin
                    button_is_filled[0] <= 1'b0;
                    cursor_inverted <= 1'b0;
                end
            end else begin
                cursor_inverted <= 1'b0;
            end
        end
    end
    
    // Display update based on screen state
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Initial display
        end else if (counter[23:0] == 24'hFFFFFF) begin
            // Periodic display update
            case (current_screen)
                SCREEN_LOCKED: begin
                    // Display "press unlock to start the os"
                    // Button already drawn in initialization
                end
                SCREEN_HOME: begin
                    // Display "loading..."
                end
                SCREEN_MENU: begin
                    // Display menu options
                end
            endcase
        end
    end

endmodule