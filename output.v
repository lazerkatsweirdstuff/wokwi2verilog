`timescale 1ns / 1ps
// ============================================================
// Generated by Wokwi2Verilog - Fixed I2C OLED Version
// Module: example
// Display: SH1107 OLED with I2C interface
// ============================================================

module example (
    // Clock and Reset
    input wire clk,
    input wire rst_n,

    // Input Pins
    input wire scl_pin,
    input wire sda_pin,
    input wire vcc_pin,
    input wire gnd_pin,
    input wire up_pin,
    input wire down_pin,
    input wire left_pin,
    input wire right_pin,
    input wire Abutton,
    input wire Bbutton
);

    // Display Parameters
    parameter SH1107_CONTROL_CO = 8'h80;
    parameter SH1107_CONTROL_DC = 8'h40;
    parameter OLED_WIDTH = 128;
    parameter OLED_PAGES = 8;  // OLED_HEIGHT / 8
    parameter OLED_HEIGHT = 64;
    parameter PIXELS_PER_SECOND = 32'd50;
    parameter BUTTON_HEIGHT = 12;
    parameter BUTTON_BORDER = 2;
    parameter MAX_BUTTONS = 10;

    // Internal Signals
    reg [31:0] counter;
    reg [6:0] i2c_address;
    reg [7:0] i2c_data_out;
    reg i2c_write_active;
    reg [2:0] i2c_bit_counter;
    reg [15:0] pixel_x;
    reg [15:0] pixel_y;
    reg [15:0] old_pixel_x;
    reg [15:0] old_pixel_y;
    reg cursor_inverted;
    reg [1:0] current_screen;
    reg a_button_was_pressed;
    reg [4:0] button_count;
    
    // Framebuffer (128x64/8 = 1024 bytes)
    reg [7:0] framebuffer [0:1023];
    
    // Button structures
    reg [15:0] button_start_x [0:9];
    reg [15:0] button_start_y [0:9];
    reg [15:0] button_width [0:9];
    reg [7:0] button_page [0:9];
    reg button_is_filled [0:9];
    
    // I2C internal signals
    reg i2c_scl;
    reg i2c_sda;
    reg [2:0] i2c_state;
    
    // Button debouncing
    reg up_pressed;
    reg down_pressed;
    reg left_pressed;
    reg right_pressed;
    reg a_pressed;
    reg b_pressed;
    reg [19:0] up_debounce;
    reg [19:0] down_debounce;
    reg [19:0] left_debounce;
    reg [19:0] right_debounce;
    reg [19:0] a_debounce;
    reg [19:0] b_debounce;
    
    // OLED state
    reg [3:0] oled_state;

    // Power Assignments
    assign vcc_pin = 1'b1;
    assign gnd_pin = 1'b0;

    // ============================================
    // Clock and Reset
    // ============================================
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            counter <= 32'd0;
            pixel_x <= 16'd64;  // Center of display
            pixel_y <= 16'd32;
            old_pixel_x <= 16'd64;
            old_pixel_y <= 16'd32;
            cursor_inverted <= 1'b0;
            current_screen <= 2'b00;  // SCREEN_LOCKED
            a_button_was_pressed <= 1'b0;
            button_count <= 5'd0;
            i2c_address <= 7'h3C;  // SH1107 default address
            i2c_scl <= 1'b1;
            i2c_sda <= 1'b1;
        end else begin
            counter <= counter + 1;
        end
    end

    // ============================================
    // I2C Master Interface
    // ============================================
    // Assign internal signals to output pins
    assign scl_pin = i2c_scl;
    assign sda_pin = i2c_sda;
    
    localparam [2:0]
        I2C_IDLE      = 3'd0,
        I2C_START     = 3'd1,
        I2C_ADDR      = 3'd2,
        I2C_DATA      = 3'd3,
        I2C_STOP      = 3'd4;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            i2c_state <= I2C_IDLE;
            i2c_scl <= 1'b1;
            i2c_sda <= 1'b1;
            i2c_bit_counter <= 3'd0;
            i2c_write_active <= 1'b0;
        end else begin
            case (i2c_state)
                I2C_IDLE: begin
                    if (i2c_write_active) begin
                        i2c_state <= I2C_START;
                        i2c_scl <= 1'b1;
                        i2c_sda <= 1'b1;
                    end
                end
                I2C_START: begin
                    i2c_sda <= 1'b0;
                    i2c_state <= I2C_ADDR;
                    i2c_bit_counter <= 3'd7;
                end
                I2C_ADDR: begin
                    i2c_scl <= 1'b0;
                    i2c_sda <= {i2c_address, 1'b0}[i2c_bit_counter];
                    if (counter[0]) begin
                        i2c_scl <= 1'b1;
                        if (i2c_bit_counter == 3'd0) begin
                            i2c_state <= I2C_DATA;
                            i2c_bit_counter <= 3'd7;
                        end else begin
                            i2c_bit_counter <= i2c_bit_counter - 1;
                        end
                    end
                end
                I2C_DATA: begin
                    i2c_scl <= 1'b0;
                    i2c_sda <= i2c_data_out[i2c_bit_counter];
                    if (counter[0]) begin
                        i2c_scl <= 1'b1;
                        if (i2c_bit_counter == 3'd0) begin
                            i2c_state <= I2C_STOP;
                        end else begin
                            i2c_bit_counter <= i2c_bit_counter - 1;
                        end
                    end
                end
                I2C_STOP: begin
                    i2c_scl <= 1'b0;
                    i2c_sda <= 1'b0;
                    if (counter[0]) begin
                        i2c_scl <= 1'b1;
                        i2c_sda <= 1'b1;
                        i2c_state <= I2C_IDLE;
                        i2c_write_active <= 1'b0;
                    end
                end
            endcase
        end
    end

    // ============================================
    // OLED Display Controller
    // ============================================
    localparam [3:0]
        OLED_IDLE     = 4'd0,
        OLED_INIT     = 4'd1,
        OLED_CLEAR    = 4'd2,
        OLED_DRAW     = 4'd3,
        OLED_UPDATE   = 4'd4;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            oled_state <= OLED_INIT;
            i2c_write_active <= 1'b0;
            i2c_data_out <= 8'h00;
        end else begin
            case (oled_state)
                OLED_INIT: begin
                    if (!i2c_write_active) begin
                        i2c_data_out <= 8'hAE;  // Display off
                        i2c_write_active <= 1'b1;
                        oled_state <= OLED_CLEAR;
                    end
                end
                OLED_CLEAR: begin
                    if (!i2c_write_active && counter[10:0] == 11'h7FF) begin
                        i2c_data_out <= 8'h00;
                        i2c_write_active <= 1'b1;
                        if (counter[15:0] == 16'hFFFF) begin
                            oled_state <= OLED_DRAW;
                        end
                    end
                end
                OLED_DRAW: begin
                    oled_state <= OLED_UPDATE;
                end
                OLED_UPDATE: begin
                    if (counter[19:0] == 20'hFFFFF) begin
                        oled_state <= OLED_DRAW;
                    end
                end
            endcase
        end
    end
    
    // Framebuffer update
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Initialize framebuffer to 0
            for (integer i = 0; i < 1024; i = i + 1) begin
                framebuffer[i] <= 8'h00;
            end
        end else if (pixel_x != old_pixel_x || pixel_y != old_pixel_y) begin
            // Calculate buffer index
            integer page = pixel_y / 8;
            integer bit_pos = pixel_y % 8;
            integer index = page * 128 + pixel_x;
            
            // Clear old pixel
            integer old_page = old_pixel_y / 8;
            integer old_bit = old_pixel_y % 8;
            integer old_index = old_page * 128 + old_pixel_x;
            framebuffer[old_index] <= framebuffer[old_index] & ~(1 << old_bit);
            
            // Set new pixel
            framebuffer[index] <= framebuffer[index] | (1 << bit_pos);
            
            old_pixel_x <= pixel_x;
            old_pixel_y <= pixel_y;
        end
    end

    // ============================================
    // Button Input Processing
    // ============================================
    // Note: Button pins are active LOW (0 when pressed)
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            up_pressed <= 1'b0;
            down_pressed <= 1'b0;
            left_pressed <= 1'b0;
            right_pressed <= 1'b0;
            a_pressed <= 1'b0;
            b_pressed <= 1'b0;
            up_debounce <= 20'd0;
            down_debounce <= 20'd0;
            left_debounce <= 20'd0;
            right_debounce <= 20'd0;
            a_debounce <= 20'd0;
            b_debounce <= 20'd0;
        end else begin
            // Debounce up_pin button
            if (!up_pin) begin
                if (up_debounce < 20'd100000) up_debounce <= up_debounce + 1;
                else up_pressed <= 1'b1;
            end else begin
                up_debounce <= 20'd0;
                up_pressed <= 1'b0;
            end
            
            // Debounce down_pin button
            if (!down_pin) begin
                if (down_debounce < 20'd100000) down_debounce <= down_debounce + 1;
                else down_pressed <= 1'b1;
            end else begin
                down_debounce <= 20'd0;
                down_pressed <= 1'b0;
            end
            
            // Debounce left_pin button
            if (!left_pin) begin
                if (left_debounce < 20'd100000) left_debounce <= left_debounce + 1;
                else left_pressed <= 1'b1;
            end else begin
                left_debounce <= 20'd0;
                left_pressed <= 1'b0;
            end
            
            // Debounce right_pin button
            if (!right_pin) begin
                if (right_debounce < 20'd100000) right_debounce <= right_debounce + 1;
                else right_pressed <= 1'b1;
            end else begin
                right_debounce <= 20'd0;
                right_pressed <= 1'b0;
            end
            
            // Debounce Abutton
            if (!Abutton) begin
                if (a_debounce < 20'd100000) a_debounce <= a_debounce + 1;
                else a_pressed <= 1'b1;
            end else begin
                a_debounce <= 20'd0;
                a_pressed <= 1'b0;
            end
            
            // Debounce Bbutton
            if (!Bbutton) begin
                if (b_debounce < 20'd100000) b_debounce <= b_debounce + 1;
                else b_pressed <= 1'b1;
            end else begin
                b_debounce <= 20'd0;
                b_pressed <= 1'b0;
            end
        end
    end
    
    // Cursor movement
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Already handled in reset
        end else begin
            if (up_pressed && pixel_y > 0) pixel_y <= pixel_y - 1;
            if (down_pressed && pixel_y < OLED_HEIGHT - 1) pixel_y <= pixel_y + 1;
            if (left_pressed && pixel_x > 0) pixel_x <= pixel_x - 1;
            if (right_pressed && pixel_x < OLED_WIDTH - 1) pixel_x <= pixel_x + 1;
        end
    end

    // ============================================
    // Screen State Machine
    // ============================================
    localparam [1:0]
        SCREEN_LOCKED = 2'b00,
        SCREEN_HOME   = 2'b01,
        SCREEN_MENU   = 2'b10;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            current_screen <= SCREEN_LOCKED;
        end else begin
            case (current_screen)
                SCREEN_LOCKED: begin
                    if (a_pressed && !a_button_was_pressed) begin
                        current_screen <= SCREEN_HOME;
                        a_button_was_pressed <= 1'b1;
                    end
                end
                SCREEN_HOME: begin
                    if (b_pressed) begin
                        current_screen <= SCREEN_MENU;
                    end
                end
                SCREEN_MENU: begin
                    if (b_pressed) begin
                        current_screen <= SCREEN_HOME;
                    end
                end
            endcase
            
            if (!a_pressed) begin
                a_button_was_pressed <= 1'b0;
            end
        end
    end

    // ============================================
    // Main Application Logic
    // ============================================
    
    // Button drawing logic
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Initialize first button (unlock)
            button_start_x[0] <= 16'd7;
            button_start_y[0] <= 16'd46;
            button_width[0] <= 16'd36;
            button_page[0] <= 8'd6;
            button_is_filled[0] <= 1'b0;
            button_count <= 5'd1;
        end else begin
            if (current_screen == SCREEN_LOCKED) begin
                if (pixel_x >= button_start_x[0] && 
                    pixel_x < button_start_x[0] + button_width[0] &&
                    pixel_y >= button_start_y[0] && 
                    pixel_y < button_start_y[0] + BUTTON_HEIGHT) begin
                    button_is_filled[0] <= 1'b1;
                    cursor_inverted <= 1'b1;
                end else begin
                    button_is_filled[0] <= 1'b0;
                    cursor_inverted <= 1'b0;
                end
            end else begin
                cursor_inverted <= 1'b0;
            end
        end
    end
    
    // Display update based on screen state
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Initial display state
        end else if (counter[23:0] == 24'hFFFFFF) begin
            // Update display every ~16.7ms (60Hz)
            case (current_screen)
                SCREEN_LOCKED: begin
                    // Display locked screen
                end
                SCREEN_HOME: begin
                    // Display home screen
                end
                SCREEN_MENU: begin
                    // Display menu
                end
            endcase
        end
    end

endmodule