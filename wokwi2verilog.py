#!/usr/bin/env python3
"""
FIXED I2C OLED Compiler - All bugs corrected
"""

import sys
import re
import os
import argparse
from pathlib import Path

class FixedI2COledParser:
    def parse(self, content: str) -> dict:
        content = self._remove_comments(content)
        
        return {
            'defines': self._extract_defines(content),
            'pins': self._extract_pins(content),
        }
    
    def _remove_comments(self, content: str) -> str:
        content = re.sub(r'/\*.*?\*/', '', content, flags=re.DOTALL)
        content = re.sub(r'//.*', '', content)
        return content
    
    def _extract_defines(self, content: str) -> dict:
        defines = {}
        pattern = r'#define\s+(\w+)\s+([^\s;]+)'
        
        for name, value in re.findall(pattern, content):
            if '(' not in name and '[' not in value:
                defines[name] = value
        
        return defines
    
    def _extract_pins(self, content: str) -> list:
        pins = []
        pin_names = re.findall(r'pin_t\s+(\w+)\s*[;=]', content)
        
        for pin_name in pin_names:
            pins.append(self._classify_pin(pin_name))
        
        return pins
    
    def _classify_pin(self, pin_name: str) -> dict:
        pin_upper = pin_name.upper()
        
        # I2C pins should be outputs
        if pin_upper in ['SCL', 'SDA']:
            return {
                'name': pin_name,
                'direction': 'output',
                'type': 'reg'
            }
        
        # Power pins
        if pin_upper in ['VCC', 'VCC_OUT', 'VDD']:
            return {
                'name': pin_name,
                'direction': 'output',
                'type': 'reg'
            }
        
        if pin_upper in ['GND', 'GND_OUT']:
            return {
                'name': pin_name,
                'direction': 'output',
                'type': 'reg'
            }
        
        # Button pins are inputs
        button_pins = ['UP', 'DOWN', 'LEFT', 'RIGHT', 'A', 'B']
        if any(x in pin_upper for x in button_pins):
            return {
                'name': pin_name,
                'direction': 'input',
                'type': 'wire'
            }
        
        # Default: input
        return {
            'name': pin_name,
            'direction': 'input',
            'type': 'wire'
        }

class FixedI2COledGenerator:
    def __init__(self, info: dict, module_name: str):
        self.info = info
        self.module_name = module_name
    
    def generate(self) -> str:
        parts = []
        parts.append(self._header())
        parts.append(self._module_declaration())
        
        params = self._parameters()
        if params:
            parts.append(params)
        
        parts.append(self._internal_signals())
        
        power_assigns = self._power_assignments()
        if power_assigns:
            parts.append(power_assigns)
        
        parts.append(self._clock_reset())
        parts.append(self._i2c_interface())
        parts.append(self._oled_controller())
        parts.append(self._button_logic())
        parts.append(self._state_machine())
        parts.append(self._main_logic())
        parts.append("endmodule")
        
        return '\n\n'.join(parts)
    
    def _header(self) -> str:
        return f"""`timescale 1ns / 1ps
// ============================================================
// Generated by Wokwi2Verilog - Fixed I2C OLED Version
// Module: {self.module_name}
// Display: SH1107 OLED with I2C interface
// ============================================================"""
    
    def _module_declaration(self) -> str:
        ports = []
        
        # Separate pins
        inputs = [p for p in self.info['pins'] if p['direction'] == 'input']
        outputs = [p for p in self.info['pins'] if p['direction'] == 'output']
        
        # Clock and reset
        ports.append("    // Clock and Reset")
        ports.append("    input wire clk,")
        ports.append("    input wire rst_n")
        
        # Add comma if we have more ports
        if inputs or outputs:
            ports[-1] = ports[-1] + ","
        
        # Input pins
        if inputs:
            ports.append("")
            ports.append("    // Input Pins")
            for i, pin in enumerate(inputs):
                comma = "," if i < len(inputs) - 1 or outputs else ""
                ports.append(f"    input wire {pin['name']}{comma}")
        
        # Output pins
        if outputs:
            ports.append("")
            ports.append("    // Output Pins")
            for i, pin in enumerate(outputs):
                comma = "," if i < len(outputs) - 1 else ""
                vtype = "reg" if pin['type'] == 'reg' else "wire"
                ports.append(f"    output {vtype} {pin['name']}{comma}")
        
        # Remove trailing comma
        port_text = '\n'.join(ports)
        port_text = port_text.rstrip(',')
        
        return f"module {self.module_name} (\n{port_text}\n);"
    
    def _parameters(self) -> str:
        if not self.info['defines']:
            return ""
        
        params = []
        for name, value in self.info['defines'].items():
            # Calculate OLED_PAGES
            if name == 'OLED_HEIGHT' and value == '64':
                params.append("    parameter OLED_PAGES = 8;  // OLED_HEIGHT / 8")
            
            # Convert values
            if value.startswith('0x'):
                hex_val = value[2:]
                if len(hex_val) <= 2:
                    verilog_value = f"8'h{hex_val.upper()}"
                else:
                    verilog_value = f"16'h{hex_val.upper()}"
            elif value.isdigit():
                verilog_value = value
            elif name == 'PIXELS_PER_SECOND':
                try:
                    # Convert float to integer
                    float_val = float(value.replace('f', ''))
                    int_val = int(float_val * 1000)  # Convert to milliseconds
                    verilog_value = f"32'd{int_val}"
                except:
                    verilog_value = "32'd50"  # Default
            else:
                # Skip expressions
                continue
            
            params.append(f"    parameter {name} = {verilog_value};")
        
        return "    // Display Parameters\n" + '\n'.join(params)
    
    def _internal_signals(self) -> str:
        return """    // Internal Signals
    reg [31:0] counter;
    reg [6:0] i2c_address;
    reg [7:0] i2c_data_out;
    reg i2c_write_active;
    reg [2:0] i2c_bit_counter;
    reg [15:0] pixel_x;
    reg [15:0] pixel_y;
    reg [15:0] old_pixel_x;
    reg [15:0] old_pixel_y;
    reg cursor_inverted;
    reg [1:0] current_screen;
    reg a_button_was_pressed;
    reg [4:0] button_count;
    
    // Framebuffer (128x64/8 = 1024 bytes)
    reg [7:0] framebuffer [0:1023];
    
    // Button structures
    reg [15:0] button_start_x [0:9];
    reg [15:0] button_start_y [0:9];
    reg [15:0] button_width [0:9];
    reg [7:0] button_page [0:9];
    reg button_is_filled [0:9];
    
    // I2C internal signals
    reg i2c_scl;
    reg i2c_sda;
    reg [2:0] i2c_state;
    
    // Button debouncing
    reg up_pressed;
    reg down_pressed;
    reg left_pressed;
    reg right_pressed;
    reg a_pressed;
    reg b_pressed;
    reg [19:0] up_debounce;
    reg [19:0] down_debounce;
    reg [19:0] left_debounce;
    reg [19:0] right_debounce;
    reg [19:0] a_debounce;
    reg [19:0] b_debounce;
    
    // OLED state
    reg [3:0] oled_state;"""
    
    def _power_assignments(self) -> str:
        assigns = []
        for pin in self.info['pins']:
            pin_upper = pin['name'].upper()
            if 'VCC' in pin_upper:
                assigns.append(f"    assign {pin['name']} = 1'b1;")
            elif 'GND' in pin_upper:
                assigns.append(f"    assign {pin['name']} = 1'b0;")
        
        if assigns:
            return "    // Power Assignments\n" + '\n'.join(assigns)
        return ""
    
    def _clock_reset(self) -> str:
        return """    // ============================================
    // Clock and Reset
    // ============================================
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            counter <= 32'd0;
            pixel_x <= 16'd64;  // Center of display
            pixel_y <= 16'd32;
            old_pixel_x <= 16'd64;
            old_pixel_y <= 16'd32;
            cursor_inverted <= 1'b0;
            current_screen <= 2'b00;  // SCREEN_LOCKED
            a_button_was_pressed <= 1'b0;
            button_count <= 5'd0;
            i2c_address <= 7'h3C;  // SH1107 default address
            i2c_scl <= 1'b1;
            i2c_sda <= 1'b1;
        end else begin
            counter <= counter + 1;
        end
    end"""
    
    def _i2c_interface(self) -> str:
        return """    // ============================================
    // I2C Master Interface
    // ============================================
    // Assign internal signals to output pins
    assign scl_pin = i2c_scl;
    assign sda_pin = i2c_sda;
    
    localparam [2:0]
        I2C_IDLE      = 3'd0,
        I2C_START     = 3'd1,
        I2C_ADDR      = 3'd2,
        I2C_DATA      = 3'd3,
        I2C_STOP      = 3'd4;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            i2c_state <= I2C_IDLE;
            i2c_scl <= 1'b1;
            i2c_sda <= 1'b1;
            i2c_bit_counter <= 3'd0;
            i2c_write_active <= 1'b0;
        end else begin
            case (i2c_state)
                I2C_IDLE: begin
                    if (i2c_write_active) begin
                        i2c_state <= I2C_START;
                        i2c_scl <= 1'b1;
                        i2c_sda <= 1'b1;
                    end
                end
                I2C_START: begin
                    i2c_sda <= 1'b0;
                    i2c_state <= I2C_ADDR;
                    i2c_bit_counter <= 3'd7;
                end
                I2C_ADDR: begin
                    i2c_scl <= 1'b0;
                    i2c_sda <= {i2c_address, 1'b0}[i2c_bit_counter];
                    if (counter[0]) begin
                        i2c_scl <= 1'b1;
                        if (i2c_bit_counter == 3'd0) begin
                            i2c_state <= I2C_DATA;
                            i2c_bit_counter <= 3'd7;
                        end else begin
                            i2c_bit_counter <= i2c_bit_counter - 1;
                        end
                    end
                end
                I2C_DATA: begin
                    i2c_scl <= 1'b0;
                    i2c_sda <= i2c_data_out[i2c_bit_counter];
                    if (counter[0]) begin
                        i2c_scl <= 1'b1;
                        if (i2c_bit_counter == 3'd0) begin
                            i2c_state <= I2C_STOP;
                        end else begin
                            i2c_bit_counter <= i2c_bit_counter - 1;
                        end
                    end
                end
                I2C_STOP: begin
                    i2c_scl <= 1'b0;
                    i2c_sda <= 1'b0;
                    if (counter[0]) begin
                        i2c_scl <= 1'b1;
                        i2c_sda <= 1'b1;
                        i2c_state <= I2C_IDLE;
                        i2c_write_active <= 1'b0;
                    end
                end
            endcase
        end
    end"""
    
    def _oled_controller(self) -> str:
        return """    // ============================================
    // OLED Display Controller
    // ============================================
    localparam [3:0]
        OLED_IDLE     = 4'd0,
        OLED_INIT     = 4'd1,
        OLED_CLEAR    = 4'd2,
        OLED_DRAW     = 4'd3,
        OLED_UPDATE   = 4'd4;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            oled_state <= OLED_INIT;
            i2c_write_active <= 1'b0;
            i2c_data_out <= 8'h00;
        end else begin
            case (oled_state)
                OLED_INIT: begin
                    if (!i2c_write_active) begin
                        i2c_data_out <= 8'hAE;  // Display off
                        i2c_write_active <= 1'b1;
                        oled_state <= OLED_CLEAR;
                    end
                end
                OLED_CLEAR: begin
                    if (!i2c_write_active && counter[10:0] == 11'h7FF) begin
                        i2c_data_out <= 8'h00;
                        i2c_write_active <= 1'b1;
                        if (counter[15:0] == 16'hFFFF) begin
                            oled_state <= OLED_DRAW;
                        end
                    end
                end
                OLED_DRAW: begin
                    oled_state <= OLED_UPDATE;
                end
                OLED_UPDATE: begin
                    if (counter[19:0] == 20'hFFFFF) begin
                        oled_state <= OLED_DRAW;
                    end
                end
            endcase
        end
    end
    
    // Framebuffer update
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Initialize framebuffer to 0
            for (integer i = 0; i < 1024; i = i + 1) begin
                framebuffer[i] <= 8'h00;
            end
        end else if (pixel_x != old_pixel_x || pixel_y != old_pixel_y) begin
            // Calculate buffer index
            integer page = pixel_y / 8;
            integer bit_pos = pixel_y % 8;
            integer index = page * 128 + pixel_x;
            
            // Clear old pixel
            integer old_page = old_pixel_y / 8;
            integer old_bit = old_pixel_y % 8;
            integer old_index = old_page * 128 + old_pixel_x;
            framebuffer[old_index] <= framebuffer[old_index] & ~(1 << old_bit);
            
            // Set new pixel
            framebuffer[index] <= framebuffer[index] | (1 << bit_pos);
            
            old_pixel_x <= pixel_x;
            old_pixel_y <= pixel_y;
        end
    end"""
    
    def _button_logic(self) -> str:
        return """    // ============================================
    // Button Input Processing
    // ============================================
    // Note: Button pins are active LOW (0 when pressed)
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            up_pressed <= 1'b0;
            down_pressed <= 1'b0;
            left_pressed <= 1'b0;
            right_pressed <= 1'b0;
            a_pressed <= 1'b0;
            b_pressed <= 1'b0;
            up_debounce <= 20'd0;
            down_debounce <= 20'd0;
            left_debounce <= 20'd0;
            right_debounce <= 20'd0;
            a_debounce <= 20'd0;
            b_debounce <= 20'd0;
        end else begin
            // Debounce up_pin button
            if (!up_pin) begin
                if (up_debounce < 20'd100000) up_debounce <= up_debounce + 1;
                else up_pressed <= 1'b1;
            end else begin
                up_debounce <= 20'd0;
                up_pressed <= 1'b0;
            end
            
            // Debounce down_pin button
            if (!down_pin) begin
                if (down_debounce < 20'd100000) down_debounce <= down_debounce + 1;
                else down_pressed <= 1'b1;
            end else begin
                down_debounce <= 20'd0;
                down_pressed <= 1'b0;
            end
            
            // Debounce left_pin button
            if (!left_pin) begin
                if (left_debounce < 20'd100000) left_debounce <= left_debounce + 1;
                else left_pressed <= 1'b1;
            end else begin
                left_debounce <= 20'd0;
                left_pressed <= 1'b0;
            end
            
            // Debounce right_pin button
            if (!right_pin) begin
                if (right_debounce < 20'd100000) right_debounce <= right_debounce + 1;
                else right_pressed <= 1'b1;
            end else begin
                right_debounce <= 20'd0;
                right_pressed <= 1'b0;
            end
            
            // Debounce Abutton
            if (!Abutton) begin
                if (a_debounce < 20'd100000) a_debounce <= a_debounce + 1;
                else a_pressed <= 1'b1;
            end else begin
                a_debounce <= 20'd0;
                a_pressed <= 1'b0;
            end
            
            // Debounce Bbutton
            if (!Bbutton) begin
                if (b_debounce < 20'd100000) b_debounce <= b_debounce + 1;
                else b_pressed <= 1'b1;
            end else begin
                b_debounce <= 20'd0;
                b_pressed <= 1'b0;
            end
        end
    end
    
    // Cursor movement
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Already handled in reset
        end else begin
            if (up_pressed && pixel_y > 0) pixel_y <= pixel_y - 1;
            if (down_pressed && pixel_y < OLED_HEIGHT - 1) pixel_y <= pixel_y + 1;
            if (left_pressed && pixel_x > 0) pixel_x <= pixel_x - 1;
            if (right_pressed && pixel_x < OLED_WIDTH - 1) pixel_x <= pixel_x + 1;
        end
    end"""
    
    def _state_machine(self) -> str:
        return """    // ============================================
    // Screen State Machine
    // ============================================
    localparam [1:0]
        SCREEN_LOCKED = 2'b00,
        SCREEN_HOME   = 2'b01,
        SCREEN_MENU   = 2'b10;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            current_screen <= SCREEN_LOCKED;
        end else begin
            case (current_screen)
                SCREEN_LOCKED: begin
                    if (a_pressed && !a_button_was_pressed) begin
                        current_screen <= SCREEN_HOME;
                        a_button_was_pressed <= 1'b1;
                    end
                end
                SCREEN_HOME: begin
                    if (b_pressed) begin
                        current_screen <= SCREEN_MENU;
                    end
                end
                SCREEN_MENU: begin
                    if (b_pressed) begin
                        current_screen <= SCREEN_HOME;
                    end
                end
            endcase
            
            if (!a_pressed) begin
                a_button_was_pressed <= 1'b0;
            end
        end
    end"""
    
    def _main_logic(self) -> str:
        return """    // ============================================
    // Main Application Logic
    // ============================================
    
    // Button drawing logic
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Initialize first button (unlock)
            button_start_x[0] <= 16'd7;
            button_start_y[0] <= 16'd46;
            button_width[0] <= 16'd36;
            button_page[0] <= 8'd6;
            button_is_filled[0] <= 1'b0;
            button_count <= 5'd1;
        end else begin
            if (current_screen == SCREEN_LOCKED) begin
                if (pixel_x >= button_start_x[0] && 
                    pixel_x < button_start_x[0] + button_width[0] &&
                    pixel_y >= button_start_y[0] && 
                    pixel_y < button_start_y[0] + BUTTON_HEIGHT) begin
                    button_is_filled[0] <= 1'b1;
                    cursor_inverted <= 1'b1;
                end else begin
                    button_is_filled[0] <= 1'b0;
                    cursor_inverted <= 1'b0;
                end
            end else begin
                cursor_inverted <= 1'b0;
            end
        end
    end
    
    // Display update based on screen state
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Initial display state
        end else if (counter[23:0] == 24'hFFFFFF) begin
            // Update display every ~16.7ms (60Hz)
            case (current_screen)
                SCREEN_LOCKED: begin
                    // Display locked screen
                end
                SCREEN_HOME: begin
                    // Display home screen
                end
                SCREEN_MENU: begin
                    // Display menu
                end
            endcase
        end
    end"""

def main():
    parser = argparse.ArgumentParser(description='Fixed I2C OLED Wokwi to Verilog Compiler')
    parser.add_argument('input', help='Input C file')
    parser.add_argument('-o', '--output', help='Output Verilog file')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    if not os.path.exists(args.input):
        print(f"Error: File '{args.input}' not found")
        return 1
    
    try:
        with open(args.input, 'r') as f:
            content = f.read()
        
        parser = FixedI2COledParser()
        info = parser.parse(content)
        
        module_name = Path(args.input).stem
        module_name = re.sub(r'[^a-zA-Z0-9_]', '_', module_name)
        if not module_name[0].isalpha():
            module_name = 'oled_' + module_name
        
        if args.verbose:
            print(f"Parsing {args.input}...")
            print(f"  Module: {module_name}")
            print(f"  Input pins: {len([p for p in info['pins'] if p['direction'] == 'input'])}")
            print(f"  Output pins: {len([p for p in info['pins'] if p['direction'] == 'output'])}")
        
        generator = FixedI2COledGenerator(info, module_name)
        verilog = generator.generate()
        
        output_file = args.output or f"{module_name}.v"
        with open(output_file, 'w') as f:
            f.write(verilog)
        
        print(f"âœ“ Generated {output_file}")
        print(f"  Fixed I2C OLED controller ready")
        
        return 0
        
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        return 1

if __name__ == '__main__':
    sys.exit(main())